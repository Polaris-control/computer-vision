import math
import numpy as np
from PIL import Image

def boxfilter(n):
    assert n % 2 != 0, "Dimension must be odd"
    box_filter = np.full((n,n),1/(n*n))
    return box_filter

# Test cases
print(boxfilter(3))
print(boxfilter(5))
print(boxfilter(7))

def gauss1d(sigma):
    length = int(np.ceil(6 * sigma))
    if length % 2 == 0:
        length += 1
    
    x = np.arange(-length // 2, length // 2 + 1)
    gaussian_filter = np.exp(-x ** 2 / (2 * sigma ** 2))
    normalized_filter = gaussian_filter / np.sum(gaussian_filter)
    
    return normalized_filter

# Test cases
sigmas = [0.3, 0.5, 1, 2]
for sigma in sigmas:
    print(f"Sigma = {sigma}:")
    print(gauss1d(sigma))
    print()


def gauss2d(sigma):
    # Generate 1D Gaussian filter
    length = int(np.ceil(6 * sigma))
    if length % 2 == 0:
        length += 1
    x = np.arange(-length // 2, length // 2 + 1)
    gaussian_filter_1d = np.exp(-x ** 2 / (2 * sigma ** 2))
    normalized_filter_1d = gaussian_filter_1d / np.sum(gaussian_filter_1d)
    
    # Generate 2D Gaussian filter
    gaussian_filter_2d = np.outer(normalized_filter_1d, normalized_filter_1d)
    
    return gaussian_filter_2d

# Test cases
sigmas = [0.5, 1]
for sigma in sigmas:
    print(f"Sigma = {sigma}:")
    print(gauss2d(sigma))
    print()


def convolve2d(array, filter):
    # Get dimensions of input array and filter
    array_height, array_width = array.shape
    filter_height, filter_width = filter.shape
    
    # Calculate padding needed for convolution
    pad_height = filter_height // 2
    pad_width = filter_width // 2
    
    # Create zero-padded array
    padded_array = np.pad(array, ((pad_height, pad_height), (pad_width, pad_width)), mode='constant')
    
    # Initialize result array
    result = np.zeros_like(array, dtype=np.float32)
    
    # Perform convolution
    for i in range(array_height):
        for j in range(array_width):
            # Extract neighborhood
            neighborhood = padded_array[i:i+filter_height, j:j+filter_width]
            # Convolution
            result[i, j] = np.sum(neighborhood * filter)
    
    return result

def gaussconvolve2d(array, sigma):
    # Generate 2D Gaussian filter
    filter = gauss2d(sigma)
    
    # Perform convolution
    result = convolve2d(array, filter)
    
    return result

# Load image and convert to grayscale numpy array
image = Image.open("3a_lion.bmp")
image_gray = image.convert("L")
image_array = np.array(image_gray, dtype=np.float32)

# Apply Gaussian convolution with sigma of 3
sigma = 3
filtered_image_array = gaussconvolve2d(image_array, sigma)

# Convert back to unsigned integer format
filtered_image_array = filtered_image_array.astype(np.uint8)

# Convert array back to image
filtered_image = Image.fromarray(filtered_image_array)

# Show original and filtered images
image.show()
filtered_image.show()

def gaussconvolve2d(array, sigma):
    # Generate 2D Gaussian filter
    filter = gauss2d(sigma)
    
    # Perform convolution
    result = convolve2d(array, filter)
    
    return result

# Load the image
image = Image.open("3a_lion_bmp")

# Convert the image to a numpy array
image_array = np.array(image, dtype=np.float32)

# Choose an appropriate sigma value
sigma = 3

# Create blurred version of the image for each color channel
red_channel_blurred = gaussconvolve2d(image_array[:, :, 0], sigma)
green_channel_blurred = gaussconvolve2d(image_array[:, :, 1], sigma)
blue_channel_blurred = gaussconvolve2d(image_array[:, :, 2], sigma)

# Compose the channels back to the color image
blurred_image_array = np.stack((red_channel_blurred, green_channel_blurred, blue_channel_blurred), axis=-1)

# Convert the array back to unsigned integer format
blurred_image_array = blurred_image_array.astype(np.uint8)

# Convert the array back to image
blurred_image = Image.fromarray(blurred_image_array)

# Save the blurred image
blurred_image.save("blurred_image.png")

# Display the blurred image
blurred_image.show()


# Choose an appropriate sigma value for high frequency
sigma_high_freq = sigma

# Compute low-frequency blurred version of the image for each color channel
red_channel_low_freq = gaussconvolve2d(image_array[:, :, 0], sigma_high_freq)
green_channel_low_freq = gaussconvolve2d(image_array[:, :, 1], sigma_high_freq)
blue_channel_low_freq = gaussconvolve2d(image_array[:, :, 2], sigma_high_freq)

# Create high-frequency version of the image for each color channel
red_channel_high_freq = image_array[:, :, 0] - red_channel_low_freq
green_channel_high_freq = image_array[:, :, 1] - green_channel_low_freq
blue_channel_high_freq = image_array[:, :, 2] - blue_channel_low_freq

# Add 128 to visualize the high-frequency image
red_channel_high_freq_visualized = red_channel_high_freq + 128
green_channel_high_freq_visualized = green_channel_high_freq + 128
blue_channel_high_freq_visualized = blue_channel_high_freq + 128

# Compose the channels back to form the high-frequency color image
high_freq_image_array = np.stack((red_channel_high_freq_visualized, green_channel_high_freq_visualized, blue_channel_high_freq_visualized), axis=-1)

# Convert the array back to unsigned integer format
high_freq_image_array = high_freq_image_array.astype(np.uint8)

# Convert the array back to image using PIL
high_freq_image = Image.fromarray(high_freq_image_array)

# Save the high frequency image
high_freq_image.save("high_freq_image.png")

# Display the high-frequency image
high_freq_image.show()

# Clamp pixel values to ensure they are within the valid range
def clamp(pixel_value):
    return max(0, min(pixel_value, 255))

# Clamp pixel values of low frequency image
red_channel_low_freq_clamped = np.array([[clamp(val) for val in row] for row in red_channel_low_freq])
green_channel_low_freq_clamped = np.array([[clamp(val) for val in row] for row in green_channel_low_freq])
blue_channel_low_freq_clamped = np.array([[clamp(val) for val in row] for row in blue_channel_low_freq])

# Clamp pixel values of high frequency image
red_channel_high_freq_clamped = np.array([[clamp(val) for val in row] for row in red_channel_high_freq])
green_channel_high_freq_clamped = np.array([[clamp(val) for val in row] for row in green_channel_high_freq])
blue_channel_high_freq_clamped = np.array([[clamp(val) for val in row] for row in blue_channel_high_freq])

# Add low and high frequency images per channel
red_channel_hybrid = red_channel_high_freq_clamped + red_channel_low_freq_clamped
green_channel_hybrid = green_channel_high_freq_clamped + red_channel_low_freq_clamped
blue_channel_hybrid = blue_channel_high_freq_clamped + red_channel_low_freq_clamped

# Compose the channels back to form the final hybrid image
hybrid_image_array = np.stack((red_channel_hybrid, green_channel_hybrid, blue_channel_hybrid), axis=-1)

# Convert the array back to unsigned integer format
hybrid_image_array = hybrid_image_array.astype(np.uint8)

# Convert the array back to image using PIL
hybrid_image = Image.fromarray(hybrid_image_array)

# Save the hybrid image
hybrid_image.save("hybrid_image_high_freq.png")

# Display the hybrid image
hybrid_image.show()


#代码通过使用高斯滤波器对图像进行模糊处理，并计算了原始图像的低频成分和高频成分。然后，它将这些成分组合起来创建了一个混合图像，
其中低频部分是原始图像的模糊版本，而高频部分包含原始图像中的细节。最后，代码对生成的图像进行了像素值的截断和处理，确保其在合理范围内。
